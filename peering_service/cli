#!/usr/bin/env python3
#
# A simple peering service CLI which makes use of the Graphiant SDK.
#
# A peering service is a Graphiant concept which allows prefix consumption
# between enterprises with optional overlapping address spaces.

from ipaddress import IPv4Network
from typing import Any, Dict, List, Optional
import click
from rich.table import Table
from rich.console import Console

import peering_services
from utils import readable_status, short_peer_type, epoch_to_utc


@click.group()
def cli():
    """A sample application which uses the Graphiant API to introspect peering services."""
    pass


# --- summary group ---
@cli.group()
def summary():
    """Commands for displaying service related items."""
    pass


# --- create group ---
@cli.group()
def create():
    """Commands for creating service related items."""
    pass


# --- summary lan-segments subcommand ---
@summary.command()
@click.argument("id", required=False, type=int)
@click.option(
    "--context",
    "context",
    type=click.Choice(["publisher", "proxy"], case_sensitive=False),
    default="publisher",
)
def lan_segments(context: str, id: Optional[int] = None):
    """Show all or a specific lan segment(s)"""
    service_mgr = peering_services.PeeringServicesMgr()

    if id is not None:
        lan_segments = service_mgr.get_lan_segment_by_id(context, id=id)
    else:
        lan_segments = service_mgr.get_lan_segments(context)

    console = Console()
    table = Table(title="Lan Segment (VRFs)")

    table.add_column("Name", style="cyan")
    table.add_column("ID", style="purple")
    table.add_column("Desc", style="magenta")
    table.add_column("Created", style="blue")
    table.add_column("Interface Refs", style="yellow")
    table.add_column("Device Refs", style="green")
    table.add_column("Site List Refs", style="red")

    for entry in lan_segments.get("entries", []):
        created = entry.get("createdAt", {})
        table.add_row(
            entry.get("name", ""),
            str(entry.get("id")),
            entry.get("description", ""),
            epoch_to_utc(created.get("seconds"), created.get("nanos")),
            str(entry.get("associatedInterfaces", "0")),
            str(entry.get("edgeReferences", "0")),
            str(entry.get("siteListReferences", "0")),
        )

    console.print(table)


# --- summary devices subcommand ---
@summary.command()
@click.argument("id", required=False, type=int)
@click.option(
    "--context",
    "context",
    type=click.Choice(["publisher", "proxy"], case_sensitive=False),
    default="publisher",
)
def devices(context, id: Optional[int] = None):
    """Show all or a specific devices(s) for the publisher or customer"""
    service_mgr = peering_services.PeeringServicesMgr()

    edges = service_mgr.get_edges(context).get("edgesSummary", [])

    console = Console()
    table = Table(title="Devices")

    table.add_column("Hostname", style="cyan")
    table.add_column("Role", style="blue")
    table.add_column("Status", style="red")
    table.add_column("ID", style="purple")
    table.add_column("Enterprise", style="magenta")
    table.add_column("Portal Status", style="yellow")
    table.add_column("Site", style="green")
    table.add_column("SW Name", style="red")

    for dev in edges:
        table.add_row(
            dev.get("hostname", ""),
            dev.get("role", ""),
            dev.get("status", ""),
            str(dev.get("deviceId")),
            str(dev.get("enterpriseId")),
            dev.get("portalStatus", ""),
            dev.get("site", ""),
            dev.get("swName", ""),
        )

    console.print(table)


# --- summary sites subcommand ---
@summary.command()
@click.argument("id", required=False, type=int)
@click.option(
    "--context",
    "context",
    type=click.Choice(["publisher", "proxy"], case_sensitive=False),
    default="publisher",
)
def sites(context: str, id: Optional[int] = None):
    """Show all sites for the publisher customer"""
    service_mgr = peering_services.PeeringServicesMgr()

    if id is not None:
        sites = service_mgr.get_site_by_id(context, id=id)
    else:
        sites = service_mgr.get_sites(context)

    console = Console()
    table = Table(title="Sites")

    table.add_column("Name", style="cyan")
    table.add_column("ID", style="purple")
    table.add_column("Created", style="blue")
    table.add_column("Updated", style="yellow")
    table.add_column("Device References", style="cyan")
    table.add_column("Num Lan Segments", style="green")
    table.add_column("Site List References", style="red")

    for entry in sites.get("sites", []):
        created = entry.get("createdAt", {})
        updated = entry.get("updatedAt", {})
        table.add_row(
            entry.get("name", ""),
            str(entry.get("id")),
            epoch_to_utc(created.get("seconds"), created.get("nanos")),
            epoch_to_utc(updated.get("seconds"), updated.get("nanos")),
            str(entry.get("edgeCount", "0")),
            str(entry.get("segmentCount", "0")),
            str(entry.get("siteListReferenceCount", "0")),
        )

    console.print(table)


# --- summary publishers subcommand ---
@summary.command()
@click.argument("service_id", required=False, type=int)
def publishers(service_id):
    """Show service publisher summary (optionally for a specific service)."""
    service_mgr = peering_services.PeeringServicesMgr()

    services_raw = service_mgr.get_services_summary(context="publisher")

    console = Console()
    table = Table(title="Peering Services")

    table.add_column("Name", style="cyan", no_wrap=True)
    table.add_column("ID", style="magenta")
    table.add_column("Status", style="green")
    table.add_column("Created", style="blue")
    table.add_column("Updated", style="blue")
    table.add_column("Matched Customers", style="red")
    table.add_column("LAN Seg", style="green")

    table.add_column("Sites", style="blue")
    table.add_column("Prefixes (Tags)", style="green")
    table.add_column("Routing Policy", style="red")

    if service_id is None:
        services = services_raw.get("info", [])
    else:
        services = [
            s for s in services_raw.get("info", []) if s.get("id", -1) == service_id
        ]

    for service in services:
        created = service.get("createdAt", {})
        updated = service.get("updatedAt", {})

        id = service.get("id", -1)

        details = service_mgr.get_producer_details(id=id)
        policy = details.get("policy", {}).get("policy", {})
        sites = []
        for s in policy.get("sites", []):
            ss = s.get("sites", [])
            for sid in ss:
                sites.append(str(sid))

        prefixes = []
        for p in policy.get("prefixTags", []):
            e = f'{p.get("prefix")} ({p.get("tag", "None")})'
            prefixes.append(e)

        routing_policies = []
        for device, r in policy.get("globalObjectDeviceSummaries", {}).items():
            for rp in r.get("routingPolicies", []):
                rpstr = f'{device}\n  {rp.get("name")} ({rp.get("id")})'
                routing_policies.append(rpstr)

        table.add_row(
            service.get("name", "unknown"),
            str(id),
            readable_status(service.get("status", "unknown")),
            epoch_to_utc(created.get("seconds"), created.get("nanos")),
            epoch_to_utc(updated.get("seconds"), updated.get("nanos")),
            str(service.get("matchedCustomers")),
            str(service.get("lanSegment", -1)),
            "\n".join([s for s in sites]),
            "\n".join([p for p in prefixes]),
            "\n".join([rp for rp in routing_policies]),
        )

    console.print(table)


# --- summary customers subcommand ---
@summary.command()
@click.argument("customer_id", required=False, type=int)
def customers(customer_id: Optional[int]):
    """Show service consumer summary (optionally for a specific service)."""
    service_mgr = peering_services.PeeringServicesMgr()

    customers_raw = service_mgr.get_customer_summary()

    console = Console()
    table = Table(title="Customers")

    table.add_column("Name", style="cyan", no_wrap=True)
    table.add_column("ID", style="magenta")
    table.add_column("Admins", style="yellow")
    table.add_column("Type", style="cyan")
    table.add_column("Status", style="green")
    table.add_column("Updated", style="blue")
    table.add_column("Matched Services", style="red")

    for c in customers_raw.get("customers", []):
        id = c.get("id")
        if customer_id is not None and id != customer_id:
            continue

        admins = "\n".join([a for a in c.get("adminEmails", [])])
        updated = c.get("updatedAt", {})
        match_details = service_mgr.get_customer_match_details(customer_id=id)
        ms = []
        for service in match_details.get("services", []):
            ms.append(
                f'{service.get("name")}\n  id: {service.get("id")}\n  status: {readable_status(service.get("status"))}'
            )

        if ms:
            matched_services = "\n".join(ms)
        else:
            matched_services = "None"

        table.add_row(
            c.get("name"),
            str(c.get("id", -1)),
            admins,
            c.get("type"),
            readable_status(c.get("status")),
            epoch_to_utc(updated.get("seconds"), updated.get("nanos")),
            matched_services,
        )

    console.print(table)


def format_ipsec_cfg(tunnel_cfg: Dict[str, Any]) -> str:
    """
    Format the IPSec VPN configuration for a given tunnel from the site to site VPN config.
    """
    s2svpn_row = f'\n  IKE Version: {tunnel_cfg.get("ikeVersion")}'
    s2svpn_row += f'\n  IKE Auth Alg: {tunnel_cfg.get("ikeAuthenticationAlgorithm")}'
    s2svpn_row += f'\n  IKE Enc Type: {tunnel_cfg.get("ikeEncryptionAlgorithm")}'
    s2svpn_row += f'\n  IKE Lifetime: {tunnel_cfg.get("ikeLifetime")}'
    s2svpn_row += f'\n  IKE DH: {tunnel_cfg.get("ikeDhAlgorithm")}'
    s2svpn_row += f'\n  Ipsec Protocol: {tunnel_cfg.get("ipsecProtocol")}'
    s2svpn_row += (
        f'\n  Ipsec Auth Alg: {tunnel_cfg.get("ipsecAuthenticationAlgorithm")}'
    )
    s2svpn_row += f'\n  Ipsec Lifetime: {tunnel_cfg.get("ipsecLifetime")}'
    s2svpn_row += f'\n  Ipsec Mode: {tunnel_cfg.get("ipsecMode")}'
    s2svpn_row += f'\n  Ipsec Pfs Alg: {tunnel_cfg.get("ipsecPfsAlgorithm")}'
    s2svpn_row += f'\n  DPD Interval: {tunnel_cfg.get("dpdInterval")}'
    s2svpn_row += f'\n  DPD Retries: {tunnel_cfg.get("dpdRetries")}'
    s2svpn_row += f'\n  IKE local ID: {tunnel_cfg.get("localIkeId")}'
    s2svpn_row += f'\n  Graphiant IKE ID: {tunnel_cfg.get("graphiantIkeId")}'
    s2svpn_row += f'\n  Local tunnel ip: {tunnel_cfg.get("localTunnelIp")}'
    s2svpn_row += f'\n  Graphiant tunnel ip: {tunnel_cfg.get("graphiantTunnelIp")}'
    s2svpn_row += (
        f'\n  Graphiant outer tunnel ip: {tunnel_cfg.get("graphiantOuterTunnelIp")}'
    )
    s2svpn_row += f'\n  Local outer tunnel ip: {tunnel_cfg.get("localOuterTunnelIp")}'
    s2svpn_row += f'\n  Local tunnel ipv6: {tunnel_cfg.get("localTunnelIpv6")}'
    s2svpn_row += f'\n  Graphiant tunnel ipv6: {tunnel_cfg.get("graphiantTunnelIpv6")}'
    return s2svpn_row


def format_routing_cfg(routing: Dict[str, Any]) -> str:
    """
    Format routing information from the site to site VPN config.
    """
    s2svpn_row = "\nRouting"
    static = routing.get("static", {})
    if static:
        s2svpn_row += "\n  Static"
        dests = "\n      ".join(static.get("destinationPrefix", []))
        s2svpn_row += f"\n    Destination: {dests}"

    bgp = routing.get("bgp", {})
    if bgp:
        s2svpn_row += "\n  BGP"
        s2svpn_row += f'\n    Send Community: {bgp.get("sendCommunity")}'
        s2svpn_row += f'\n    Peer ASN: {bgp.get("peerAsn")}'
        s2svpn_row += f'\n    MD5 Pass: {bgp.get("md5Password", {}).get("md5_password", "Not Set")}'
        s2svpn_row += f'\n    Keepalive Timer: {bgp.get("keepaliveTimer")}'
        s2svpn_row += f'\n    Hold Timer: {bgp.get("hold_timer")}'
        afs = bgp.get("addressFamilies", {})
        for _af, v in afs.items():
            s2svpn_row += "\n    Ipv4:"
            if "inboundPolicy" in v:
                i = v.get("inboundPolicy")
                s2svpn_row += f'\n      Inbound policy: {i.get("policy")}'

            if "outboundPolicy" in v:
                i = v.get("outboundPolicy")
                s2svpn_row += f'\n      Outbound policy: {i.get("policy")}'

    return s2svpn_row


# --- summary services subcommand ---
@summary.command()
@click.option("--customer-id", "customer_id", required=False, default=None, type=int)
@click.option("--service-id", "service_id", required=False, default=None, type=int)
def services(service_id: Optional[int], customer_id: Optional[int]):
    """Show service summary (optionally for a specific service and customer)."""
    service_mgr = peering_services.PeeringServicesMgr()

    if customer_id is None:
        customers_raw = service_mgr.get_customer_summary()
        customer_ids = [c.get("id", -1) for c in customers_raw.get("customers", [])]
    else:
        customer_ids = [customer_id]

    # Map of customer id's to a set of associated publisher service ids.
    cust_service_id_map: Dict[int, List[int]] = {}
    for cid in customer_ids:
        customer_details = service_mgr.get_customer_match_details(cid)
        for service in customer_details.get("services", []):
            id = service.get("id", -1)
            if service_id is not None:
                if id == service_id:
                    service_ids = cust_service_id_map.get(cid, [])
                    service_ids.append(id)
                    cust_service_id_map[cid] = service_ids
                    break
            else:
                service_ids = cust_service_id_map.get(cid, [])
                service_ids.append(id)
                cust_service_id_map[cid] = service_ids

    console = Console()
    table = Table(title="Matched Services")

    table.add_column("Service", style="cyan", no_wrap=True)
    table.add_column("Customer", style="purple")
    table.add_column("Sites", style="blue")
    table.add_column("Lan Seg", style="red")
    table.add_column("Service Prefixes", style="yellow")
    table.add_column("Consumer Prefixes", style="purple")
    table.add_column("VPN", style="blue")

    for cid, sids in cust_service_id_map.items():
        for sid in sids:
            details = service_mgr.get_customer_details(cid, sid)
            if "errorCode" in details:
                print(f'Warning: {details.get("detailedError")}')
                continue

            match_details = details.get("matchDetails", {})
            customer = match_details.get("customer")
            publisher = match_details.get("service")
            publisher_contacts = "\n".join(
                [c for c in publisher.get("contactEmail", [])]
            )
            publisher_details = f'Name: {publisher.get("serviceName", "Unknown")}\nId: {publisher.get("id", -1)}\nDescription: {publisher.get("description", "None")}\nCompany: {publisher.get("companyName")}\nContacts: {publisher_contacts}'
            publisher_details += f'Status: {readable_status(details.get("status"))}\nType: {short_peer_type(details.get("peerType"))}'

            emails = "\n  ".join(customer.get("emails", []))
            customer_row = f'ID: {customer.get("id")}\nName: {customer.get("companyName")}\nEmails: {emails}\nNum Sites: {customer.get("numSites")}'

            site_info = details.get("siteInformation", [])
            sites = []
            for s in site_info:
                si = s.get("sites", [])
                for site in si:
                    sites.append(str(site))

            site_row = "\n".join(sites)

            lan_segs = []
            for policy in details.get("policy", []):
                lan_segs.append(str(policy.get("lanSegment", "None")))

            lan_seg_row = "\n".join(lan_segs)

            service_prefixes_entries = []
            service_prefixes = match_details.get("servicePrefixes", [])
            for spfx in service_prefixes:
                # Dnat from customerTranlatedPrefix to prefix.
                if "customerTranslatedPrefix" in spfx:
                    s = f'I:{spfx.get("customerTranslatedPrefix", "None")}\n  -> O:{spfx.get("prefix")} ({spfx.get("tag", "None")})'
                else:
                    s = f'{spfx.get("prefix")}, T:{spfx.get("tag")}'

                service_prefixes_entries.append(s)

            consumer_prefixes_row = "\n".join(
                [p for p in match_details.get("consumerPrefixes", [])]
            )
            service_prefixes_row = "\n".join(service_prefixes_entries)

            s2svpn = details.get("siteToSiteVpn", {})
            s2svpn_emails = "\n  ".join([e for e in s2svpn.get("emails", [])])
            s2svpn_row = (
                f'Emails: {s2svpn_emails}\nRegionId: {s2svpn.get("regionId", -1)}'
            )

            tunnel_cfg = details.get("ipsecTunnelConfig", [])

            ipsec_gw = s2svpn.get("ipsecGatewayDetails", {})
            if ipsec_gw:
                s2svpn_row += f'\nName: {ipsec_gw.get("name", "unknown")}\nDestination: {ipsec_gw.get("destinationAddress", "unknown")}\nIKE Initiator: {ipsec_gw.get("ikeInitiator", "unknown")}'
                s2svpn_row += f'\nVPN Profile: {ipsec_gw.get("vpnProfile", "unknown")}'
                for t in ["tunnel1", "tunnel2"]:
                    tunnel = ipsec_gw.get(t, {})
                    if tunnel:
                        s2svpn_row += f"\nTunnel {t[-1:]}"
                        s2svpn_row += (
                            f'\n  Inside Ipv4: {tunnel.get("insideIpv4Cidr", "None")}'
                        )
                        s2svpn_row += (
                            f'\n  Inside Ipv6: {tunnel.get("insideIpv6Cidr", "None")}'
                        )
                        psk = tunnel.get("psk", "None")
                        s2svpn_row += f"\n  PSK: {psk}"
                        # Get the tunnel cfg.
                        for c in tunnel_cfg:
                            if c.get("ikePresharedKey", "None") == psk:
                                s2svpn_row += format_ipsec_cfg(c)

                routing = ipsec_gw.get("routing", {})
                if routing:
                    s2svpn_row += format_routing_cfg(routing)

                if "tcpMss" in ipsec_gw:
                    s2svpn_row += f'\nTCP MSS: {ipsec_gw.get("tcpMss")}'

                if "mtu" in ipsec_gw:
                    s2svpn_row += f'\nMTU: {ipsec_gw.get("mtu")}'

            table.add_row(
                publisher_details,
                customer_row,
                site_row,
                lan_seg_row,
                service_prefixes_row,
                consumer_prefixes_row,
                s2svpn_row,
            )

    console.print(table)


# --- create publisher subcommand ---
@create.command()
@click.argument("name", required=True, type=str)
@click.argument("description", required=False, type=str)
@click.argument(
    "service-lan-segment",
    required=True,
    type=str,
)
@click.option(
    "--site", required=True, multiple=True, help="The site the service is attached to."
)
@click.option(
    "--prefix-and-tag",
    required=True,
    multiple=True,
    help='Add a service prefix and optional tag. This option may be repeated and should take the form "10.0.2.0/24,Tag" if a tag is required, otherwise just specify the prefix.',
)
def publisher(
    name: str,
    description: str,
    service_lan_segment: str,
    site,
    prefix_and_tag,
):
    """Create a peering service publisher."""
    service_mgr = peering_services.PeeringServicesMgr()

    prefixes_and_tags = []
    for pt in prefix_and_tag:
        e = pt.split(",")
        prefix = e[0]
        if len(e) > 1:
            tag = e[1]
        else:
            tag = None

        prefixes_and_tags.append((IPv4Network(prefix), tag))

    sites = [s for s in site]

    service_mgr.create_producer(
        name,
        desc=description,
        service_lan_seg=service_lan_segment,
        site_names=sites,
        prefix_and_tag_set=prefixes_and_tags,
    )


if __name__ == "__main__":
    cli()
